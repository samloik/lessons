https://codecamp.ru/blog/python-excel-tutorial/

Далее у вас есть цикл for, который гарантирует, что все значения попадают в файл: вы говорите,
что для каждого элемента в диапазоне от 0 до 4 (5 не включительно) вы собираетесь что-то делать.
Вы будете заполнять значения построчно. Для этого вы указываете элемент строки, который появляется в каждом цикле.
Далее у вас есть еще один цикл for, который будет проходить по столбцам вашего листа.
Вы говорите, что для каждой строки на листе, вы будете смотреть на столбцы, которые идут с ним,
и вы будете заполнять значение для каждого столбца в строке. Заполнив все столбцы строки значениями,
вы перейдете к следующей строке, пока не останется строк.


# Initialize a workbook
book = xlwt.Workbook()

# Add a sheet to the workbook
sheet1 = book.add_sheet("Sheet1")

# The data
cols = ["A", "B", "C", "D", "E"]
txt = [0,1,2,3,4]

# Loop over the rows and columns and fill in the values
for num in range(5):
      row = sheet1.row(num)
      for index, col in enumerate(cols):
          value = txt[index] + num
          row.write(index, value)

# Save the result
book.save("test.xls")





https://ru.stackoverflow.com/questions/1077685/keyerror-there-is-no-item-named-xl-sharedstrings-xml-in-the-archive
Столкнулся с такой же проблемой, надеюсь, мой ответ кому-нибудь поможет.

import shutil
from zipfile import ZipFile

# Создаем временную папку
tmp_folder = '/tmp/convert_wrong_excel/'
os.makedirs(tmp_folder, exist_ok=True)

# Распаковываем excel как zip в нашу временную папку
with ZipFile('yourfile.xlsx') as excel_container:
    excel_container.extractall(tmp_folder)

# Переименовываем файл с неверным названием
wrong_file_path = os.path.join(tmp_folder, 'xl', 'SharedStrings.xml')
correct_file_path = os.path.join(tmp_folder, 'xl', 'sharedStrings.xml')
os.rename(wrong_file_path, correct_file_path)

# Запаковываем excel обратно в zip и переименовываем в исходный файл
shutil.make_archive('yourfile', 'zip', tmp_folder)
os.rename('yourfile.zip', 'yourfile.xlsx')




стр.146 Глава 6. Поиск в ширину

А вот окончательная версия кода поиска в ширину, в которой учтено это
обстоятельство:


def search(name):
    search_queue = deque()
    search_queue += graph(name]
    searched = []                          # Этот массив испопьзуется дпя отспеживания уже проверенных пюдей
    while search_queue:
        person = search_queue.popleft()
        if not person in searched:          # Чеповек проверяется топько в том спучае, еспи он не проверяпся ранее
            if person_is_seller(person):
            print person +" is а mango seller!"
            return True
        else:
        search_queue += graph[person]
        searched.append(person)             # Чеповек помечается как уже проверенный
    return False

search("you")
